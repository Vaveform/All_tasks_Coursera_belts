#include <numeric>
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
#include <iterator>
#include <deque>
#include <set>
#include <tuple>
#include <cstdint>
#include "profile.h"

using namespace std;

// – –µ–∞–ª–∏–∑—É–π—Ç–µ —à–∞–±–ª–æ–Ω –∫–ª–∞—Å—Å–∞ Paginator
template <typename It>
class IteratorRange{
private:
	It first;
	It last;
	size_t SIZE_PAGE;
public:
	IteratorRange(It f, It l, size_t s): first(f), last(l), SIZE_PAGE(s){};
	It begin() const{
		return first;
	}
	It end() const{
		return last;
	}
	size_t size() const{
		return SIZE_PAGE;
	}
};

template <typename Iterator>
class Paginator {
private:
	vector<IteratorRange<Iterator>> Values;
	size_t SIZE;
public:
	Paginator(Iterator f, Iterator l, size_t s){
		//cout << l - f << endl;
		auto start_page = f;
		auto end_page = f;
		vector<IteratorRange<Iterator>> Pages;
		while(end_page != l){
			end_page = next(start_page, min(s, size_t(l - start_page)));
			Pages.push_back(IteratorRange{start_page, end_page, size_t(end_page - start_page)});
			start_page = end_page;
		}
		Values = Pages;
		SIZE = Pages.size();
		//cout << SIZE << endl;
	};
	auto begin() const
	{
		return Values.begin();
	}
	auto end() const
	{
		return Values.end();
	}
	size_t size() const {
		return size_t(end() - begin());
	}
};

template <typename C>
auto Paginate(C& c, size_t page_size) {
  return Paginator{c.begin(), c.end(), page_size};
}

template <typename ConteinerOfVectors>
void GenerateSingleThread(ConteinerOfVectors& result,
		size_t first_row,
		size_t column_size){
	for(auto& row : result){
		row.reserve(column_size);
		for(size_t column = 0; column < column_size; column++){
			row.push_back(first_row + column);
		}
		++first_row;
	}
}

template <typename ConteinerOfVectors>
int64_t


int main(){
	vector<vector<size_t>> matrix(1000);
	LOG_DURATION("single generating");
	GenerateSingleThread(matrix, 0, 1000);
	return 0;
}
